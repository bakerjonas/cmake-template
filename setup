#!/usr/bin/env python
# vim:ft=python
#
# primitive frontend to cmake
# (c) Jonas Juselius <jonas.juselius@uit.no> and Radovan Bast <radovan.bast@uit.no>
# licensed under the GNU Lesser General Public License

import os
import sys
import string
import subprocess
from argparse import ArgumentParser

if sys.version < '2.4':
	print('requires python version >= 2.4')
	sys.exit(1)

root_directory = os.path.realpath(__file__)[:-5]
default_path = root_directory + 'build/'

# define example usage

usage = '''
  Example: ./%prog --fc=gfortran --cc=gcc'''

# initialize parser

parser = ArgumentParser(description="Setup build configurations.")

# define options

group = parser.add_argument_group('Basic options')
group.add_argument('--auto',
		action='store_true',
		default=False,
		help='try to configure --fc, --cc, --cpp  automatically [default: %(default)s]')
group.add_argument('--fc',
		action='store',
		default=None,
		help='set the Fortran compiler [default: pick automatically or based on FC=...]',
		metavar='STRING')
group.add_argument('--cc',
		action='store',
		default=None,
		help='set the C compiler [default: pick automatically or based on CC=...]',
		metavar='STRING')
group.add_argument('--cpp',
		action='store',
		default=None,
		help='set the C++ compiler [default: pick automatically or based on CXX=...]',
		metavar='STRING')
group.add_argument('--netcdf-dir',
		action='store',
		dest='netcdfdir',
		default=None,
		help='directory containing NETCDF libraries [default: pick automatically based on NETCDF_ROOT (see INSTALL.rst)]',
		metavar='PATH')
group.add_argument('--mpi',
		action='store_true',
		default=False,
		help='build using MPI parallelization [default: %(default)s]')
group.add_argument('--show',
		action='store_true',
		default=False,
		help='show cmake command and exit [default: %(default)s]')
parser.add_argument_group(group)

group = parser.add_argument_group('Change default paths')
group.add_argument('--build',
		action='store',
		default=default_path,
		help='set the build path (you can build several binaries with the same source) [default: %(default)s]',
		metavar='PATH')
group.add_argument('--prefix',
		action='store',
		dest='prefix',
		default=None,
		help='set the install path for make install [default: %(default)s]',
		metavar='PATH')
group.add_argument('--cmake',
		action='store',
		dest='alternative_cmake',
		default=None,
		help='give full path to alternative cmake binary (use this if default cmake is too old)',
		metavar='PATH')

group = parser.add_argument_group('Advanced options')
group.add_argument('--debug',
		action='store_true',
		default=False,
		help='build in debug mode (no optimization) [default: %(default)s]')
group.add_argument('--enable-tests',
		action='store_true',
		default=False,
		help='build test suite [default: %(default)s]')
group.add_argument('--check',
		action='store_true',
		default=False,
		help='enable bounds checking [default: %(default)s]')
group.add_argument('--coverage',
		action='store_true',
		default=False,
		help='enable code coverage [default: %(default)s]')
group.add_argument('--nochecks',
		action='store_true',
		default=False,
		help='disable compatibility checks [default: %(default)s]')
group.add_argument('-D',
		action="append",
		dest='cmake',
		default=[],
		help='forward directly to cmake (example: -D ENABLE_THIS=1 -D ENABLE_THAT=1); \
				you can also forward CPP defintions all the way to the program \
				(example: -D CPP="-DDEBUG")',
				metavar='STRING')
group.add_argument('--host',
		action='store',
		default=None,
		help="use predefined defaults for 'host'",
		metavar='STRING')

# process input

args = parser.parse_args()

def check_cmake_exists():
	p = subprocess.Popen('cmake --version',
			shell=True,
			stdin=subprocess.PIPE,
			stdout=subprocess.PIPE)
	if not ('cmake version' in p.communicate()[0]):
		print('   This code is built using CMake')
		print('')
		print('   CMake is not found')
		print('   get CMake at http://www.cmake.org/')
		print('   on many clusters CMake is installed')
		print('   but you have to load it first:')
		print('   $ module load cmake')
		sys.exit()

def gen_cmake_command():
	# create cmake command from flags

	command = ''

	if not args.auto:
		if args.fc:
			command += ' FC=%s' % args.fc
		if args.cc:
			command += ' CC=%s' % args.cc
		if args.cpp:
			command += ' CXX=%s' % args.cpp

	if args.alternative_cmake: 
		command += ' %s' % args.alternative_cmake
	else:
		command += ' cmake'

	if args.netcdfdir:
		if not os.path.exists(args.netcdfdir):
			print("Specified NETCDF directory does not exist!")
			sys.exit(1)
		command += ' -DNETCDF_ROOT="%s"' % args.netcdfdir

	# if fc starts with 'mpi' turn on MPI
	if args.fc and (args.fc[:3] == 'mpi' or args.fc[:3] == 'MPI'):
		args.mpi = True
	if args.mpi:
		command += ' -DENABLE_MPI=ON'

	if args.check:
		command += ' -DENABLE_BOUNDS_CHECK=ON'
	if args.coverage:
		command += ' -DENABLE_CODE_COVERAGE=ON'
	if args.nochecks:
		command += ' -DENABLE_SANITY_CHECKS=OFF'
	if args.prefix:
		command += ' -DCMAKE_INSTALL_PREFIX=' + args.prefix

	if args.debug:
		command += ' -DCMAKE_BUILD_TYPE=Debug'
	else:
		command += ' -DCMAKE_BUILD_TYPE=Release'

	if args.enable_tests:
		command += ' -DENABLE_TESTS=1'

	if args.cmake:
		for definition in args.cmake:
			command += ' -D%s' % definition

	command += ' %s' % root_directory

	print('%s\n' % command)
	if args.show:
		sys.exit()
	return command

def configure_host(host):
	if host == 'stallo':
		configure_stallo()
	else:
		print("Unknown host/system: {0}".format(host))
		sys.exit(1)

def print_build_help(build_path):
	print('   configure step is done')
	print('   now you need to compile the sources')
	print('')
	print('   to compile with configured parameters (recommended):')
	print('   $ cd ' + build_path)
	print('   $ make')
	print('')
	print('   to modify configured parameters and then compile:')
	print('   $ cd ' + build_path)
	print('   $ ccmake ' + root_directory)
	print('   $ make')

def gen_reconfigure_script(command, build_path):
	file_name = os.path.join(build_path, 'reconfigure')
	f = open(file_name, 'w')
	f.write('#!/bin/sh \n')
	f.write('%s' % command)
	f.close()
	os.system('chmod 700 %s' % file_name)

def save_setup_command(argv, build_path):
	file_name = os.path.join(build_path, 'setup_command')
	f = open(file_name, 'w')
	f.write(" ".join(sys.argv[:]))
	f.close()

def setup_build_path(build_path, only_show_command):
	if os.path.isdir(build_path):
		if not only_show_command:
			print('aborting setup - build directory %s exists already' % build_path)
			print('please first remove it and then rerun setup')
			sys.exit()
	else:
		os.makedirs(build_path, 0755)

def run_cmake(command, build_path):
	topdir = os.getcwd()
	os.chdir(build_path)
	p = subprocess.Popen(command,
			shell=True,
			stdin=subprocess.PIPE,
			stdout=subprocess.PIPE)
	s = p.communicate()[0]
	print(s)
	os.chdir(topdir)
	return s

def main():
	if len(sys.argv) == 1:
		# user has given no arguments: print help and exit
		print(parser.format_help().strip())
		sys.exit()

	check_cmake_exists()
	build_path = args.build
	setup_build_path(build_path, args.show)
	if args.host:
		configure_host(args.host)
	command = gen_cmake_command()
	status = run_cmake(command, build_path)

	if not 'Configuring incomplete' in status:
		gen_reconfigure_script(command, build_path)
		save_setup_command(sys.argv, build_path)
		print_build_help(build_path)

# host/system specific configurations

def configure_stallo():
	if not args.fc:
		args.fc = 'mpif90'
		if not args.cc:
			args.cc = 'mpicc'
		if args.mpi:
			args.fc = 'mpif90'
			args.cc = 'mpicc'

if __name__ == '__main__':
	main()

